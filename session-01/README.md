# Session 01 / Merge Tool - üè¶ Core Banking System (CBS) Importer

In this session, you are required to develop a command-line application that integrates with a Core Banking System (CBS) through a REST API. Your application will process incoming customer and contract data, provided in CSV format, and load it into the CBS system via HTTP requests.

The context: The bank previously had an internal data import tool, but it has become outdated and is no longer maintainable. Your task is to **replace this tool** with a new solution while **preserving its existing behavior**. As part of the challenge, you are provided with sample input and output files generated by the old system ‚Äì these serve as a functional reference for how the new implementation should behave.

The goal of this challenge is to simulate a real-world scenario where data needs to be validated, transformed, and securely transferred to a backend service. You will also be responsible for logging the results of each decision and action taken during the import process.

Get ready to show off your engineering skills by handling structured data, interacting with APIs, and building a robust, logic-driven automation tool!

## üõ†Ô∏è Task Description

Your task is to develop a command-line application (CLI) that imports customer and contract data into a Core Banking System (CBS) via its REST API.

The input data consists of two CSV files:
- `customers.csv`: contains customer records
- `contracts.csv`: contains contract records, each referring to a customer and product

### üîÅ Import Logic

Before performing the import, your application **must first query the current state of the CBS** by fetching existing data from the API. Based on this data, your application should determine which records in the CSV files are:
- **New** and should be imported via API,
- **Already exist** in the CBS and should be skipped,

The business logic that determines how records are handled must be implemented by you, and its result must be clearly documented in the output.

### üßæ Output

Your application must generate a **CSV output log file** for each input file:
- `customers.output.csv`
- `contracts.output.csv`

Each output row should contain:
- A `row` column that refers to the **line number** (starting from 1) in the original input CSV file,
- A `type` column indicating the **reasoning or rule** applied
- Any other fields relevant to the log (e.g. ids for easier review).

> ‚ö†Ô∏è You do **not** need to log the actual API requests or responses. It is assumed that the API behaves correctly when valid data is sent.

### üß© Goal

This challenge tests your ability to:
- Process and analyze structured input data (CSV),
- Query and interpret existing data via REST APIs,
- Apply domain-specific logic to decide what to import or skip,
- Produce clear, structured log files that trace the import process,
- Build a robust, maintainable command-line tool.

## üë§ Customer Import Logic

Customer data must be imported into the Core Banking System (CBS) following a matching strategy that compares new entries (from `customers.csv`) with existing customers (fetched from the CBS API).

### üîé Matching Rules

For each customer record in the CSV, compare the following 5 fields:
- `firstName`
- `lastName`
- `motherName`
- `birthDate`
- `birthPlace`

Matching levels are defined as follows:

#### ‚úÖ PERFECT_MATCH
- All **5 fields match** exactly with an existing customer in the CBS.
- Result: No import is performed.
- `type` in output CSV: `PERFECT_MATCH`

#### ‚ö†Ô∏è PARTIAL_MATCH
- **Exactly 4 out of 5 fields** match an existing customer in the CBS.
- Result: The record is considered a match, and **no import is performed**, but a warning should be noted in the log.
- `type` in output CSV: `PARTIAL_MATCH`

#### üÜï NEW
- Anything else (3 or fewer fields match) is considered a new customer.
- Result: The record with all attributes must be imported
- The `id` from the CSV (CRM system) must be **preserved and used as the ID** in the CBS.
- `type` in output CSV: `NEW`

### üì• Expected JSON format for import

If the record is determined to be `NEW`, it should be imported using the following format:

```json
{
  "id": "example-id-crm-123",              // original ID from CSV
  "firstName": "Anna",
  "lastName": "Kov√°cs",
  "birthDate": "1990-02-12",
  "birthPlace": "Budapest",
  "motherName": "Kiss M√°ria",
  "gender": "F",
  "postalCode": "1132",
  "email": "anna.kovacs@example.com",
  "phone": "06201234567",
  "membership": "gold",
  "joinedAt": "2024-05-01"
}
```

### üìÑ `01-customers.output.csv` Format

This file logs the results of the customer import process. Each row corresponds to a customer from the original `customers.csv` input file and shows how the system processed it.

| Column Name | Description |
|-------------|-------------|
| `row`       | Line number from the input `customers.csv` (starting from 1) |
| `type`      | Type of handling applied, one of: `PERFECT_MATCH`, `PARTIAL_MATCH`, `NEW` |
| `crmId`     | The customer ID from the CSV file (external system) |
| `cbsId`     | The customer ID in the CBS system |

### üîÑ Value rules

- If the customer was **matched** (`PERFECT_MATCH` or `PARTIAL_MATCH`), `cbsId` contains the **existing CBS ID**, which is **different** from the `crmId`.
- If the customer is **new** (`NEW`), the customer is imported with their original ID. Therefore, `crmId` and `cbsId` will be the **same**.

### üß™ Example rows

```csv
row,type,crmId,cbsId
1,PERFECT_MATCH,crm-001,25705eca-ded5-4c69-a0db-50f07b3db286
2,PARTIAL_MATCH,crm-002,0cb7902a-caf5-4d4a-9494-b5eb6a33fb92
3,NEW,crm-003,crm-003
```

## üìÑ Contract Import Logic

Contract data must be imported into the Core Banking System (CBS) based on product activity and contract recency. Each contract in the `contracts.csv` file refers to an existing customer and product.

The CBS already holds data about customers and products. Your task is to determine how to handle each contract based on the product's status and whether the contract is the most recent for the given customer-product pair.

### üîé Import Rules

For each contract record:

#### üóÉÔ∏è ARCHIVED
- If the related product is marked as **inactive** in the CBS.
- Result: The contract must **not be imported**.
- `type` in output CSV: `ARCHIVED`

#### ‚ö†Ô∏è IMPORTED AS INACTIVE
- If the product is active, but this contract is **not the latest** by `contractDate` for the same customer-product pair.
- Result: Import the contract with status `"inactive"`.
- `type` in output CSV: `IMPORTED AS INACTIVE`

#### ‚úÖ IMPORTED AS ACTIVE
- If the product is active, and this contract is the **latest** (by `contractDate`) for the same customer-product pair.
- Result: Import the contract with status `"active"`.
- `type` in output CSV: `IMPORTED AS ACTIVE`

> üïì `contractDate` is used to determine the most recent contract for each customer-product pair.

### ‚öôÔ∏è Special Handling: `params`

- The `params` column in the CSV contains a **JSON string**.
- This string must be parsed into a valid JSON object before sending it to the API.
- The **structure of `params` depends on the product type**, and may contain different keys and value types.

### üì• Expected JSON format for import

If the contract is imported, it must be sent in the following structure:

```json
{
  "id": "95f3a6c6-ac58-42e7-a6ff-c58c5198f752",
  "customerId": "76011f01-2f40-466c-9185-9c419ea3dd88",
  "productId": "1",
  "contractDate": "2021-01-19T20:19:46.044Z",
  "status": "active",
  "price": 86.33,
  "params": {
    "expiredAt": "2024-05-02T19:19:46.044Z",
    "number": "5446-5999-6485-4956",
    "cvv": "563"
  }
}
```

### üìÑ `01-contracts.output.csv` Format

This file logs the result of the contract import process. Each row corresponds to a record from the original `contracts.csv` input file and captures the result of the business logic applied to it.

| Column Name | Description |
|-------------|-------------|
| `row`       | Line number in the input `contracts.csv` (starting from 1) |
| `type`      | Action taken based on the logic, one of: `ARCHIVED`, `IMPORTED AS INACTIVE`, `IMPORTED AS ACTIVE` |
| `id`        | Contract ID from the original CSV input (matches the `id` column in `contracts.csv`) |

### üß™ Example rows

```csv
row,type,id
1,ARCHIVED,contract-001
2,IMPORTED AS INACTIVE,contract-002
3,IMPORTED AS ACTIVE,contract-003
```

## üì¶ Submission Instructions

Your solution must be submitted via a **Git repository**.

The repository should contain:

- The complete **source code** of your CLI application
- A clearly written `README.md` file that includes:
  - How to **build** the application (e.g., dependencies, tools, build commands)
  - How to **run** the application
  - Where to place the input files (`customers.csv`, `contracts.csv`)
  - Where to expect the output log files

### ‚úÖ Example `README.md` content

Below is an example structure your `README.md` file could follow:

```markdown
# CBS Import Tool

## Requirements
- Python 3.11+
- Requests library (install with `pip install -r requirements.txt`)

## Build / Setup
No build required, just install dependencies:

```bash
pip install -r requirements.txt